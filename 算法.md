# 标准算法：

标准算法的实现都是依赖容器，一般是由迭代器的容器，输入的参数还包括**仿函数**或者是**lambda表达式**

## 内建函数对象

内涵：是STL内定义好的模板类（仿函数），覆盖了常用的算术、关系和逻辑仿函数

调用：包含头文件`#include<functional>`

注意：是一个类，需要实例化后才能用

内容：

- 算术仿函数：返回值类型和输入类型相同
- `template<class T> T plus<T>`                //加法仿函数
- `template<class T> T minus<T>`              //减法仿函数
- `template<class T> T multiplies<T>`    //乘法仿函数
- `template<class T> T divides<T>`         //除法仿函数
- `template<class T> T modulus<T>`         //取模仿函数
- `template<class T> T negate<T>`           //取反仿函数

* 关系仿函数：返回值都是bool类型
* `template<class T> bool equal_to<T>`                    //等于
* `template<class T> bool not_equal_to<T>`            //不等于
* `template<class T> bool greater<T>`                      //大于
* `template<class T> bool greater_equal<T>`          //大于等于
* `template<class T> bool less<T>`                           //小于
* `template<class T> bool less_equal<T>`               //小于等于

* 逻辑仿函数
* `template<class T> bool logical_and<T>`              //逻辑与
* `template<class T> bool logical_or<T>`                //逻辑或
* `template<class T> bool logical_not<T>`              //逻辑非



## 仿函数：

仿函数本质上是一个类，类内只有一个成员函数，重载了`()`符号，在重载的`()`函数中，里面定义了自己的规则

```c++
class my_print
{
public:
    void operator()(int val)
    {
        val++;
        cout<<val<<" ";
    }
};
```

仿函数重载的函数的输入，一定要和容器内存储的数据类型一样，这样使用算法时，容器中的数据才能传递进来

调用仿函数的时候可以有两种方式，1.匿名对象调用 2.实例化对象调用。一般采用匿名对象调用，简洁高效

```c++
class my_print //定义看上面
//匿名对象调用
for_each(v1.begin() , v1.end() , my_print()); //类名后面直接加（），并不进行实例化，是一个暂时性的对象，这句话结束后就会被释放
//实例化对象调用
my_print m1;
for_each(v1.begin() , v1.end() ,m1); 
```



## 谓词：

仿函数重载的运算符`()`的返回值如果是bool的返回值，称为**谓词**



## lambda表达式：

作用是模拟一个函数。作为一种参数传递的手段，可以从外部输入参数，利用lambda表达式定义匿名函数，好处是不需要在额外写一个函数体，更简洁

**语法**：`[捕获值](参数列表)->return type{ 函数返回公式;}`，**注意在{}内有分号**

- 捕获值：访问外部的变量，可以用值访问、引用访问等方式

  `[]`不捕获外部变量

  **值捕获=：**传递时赋值。调用前外部值变化，**表达式内值不会变化**

  `[=]：`捕获所有变量，return可以是所有变量的组合

  `[x]`：只捕获x变量，在return中只能使用x

  **引用捕获&：**调用前赋值。会随着外部值的变化而变化

  `[&]：`捕获所有变量

  `[&x]：`只捕获x变量

  **隐式捕获：**必须使用不同类型的捕获符号，大部分参数传递的方式应该写在**最前面**

  `[=，&x]`：除了x是引用传递，其他的变量都是值传递

  `[&,x]:`除了x是值传递，其他变量都是引用传递，注意不能写成`[x,&]`，会报错

  `[x,&y]:`值传递x，引用传递y

- 参数列表：lambda表达式模拟的函数，需要输入的参数。相当于正常函数的形参

- ->return type：返回值的类型，可以省略，也可以用->强制规定

- 函数返回公式：返回的具体计算方式，return表达式

```c++
#include<iostream>
using namespace std;

int main()
{
    int x =1;
    double y =2.1;
    int z =90;
    auto f = [&,x](){return x+y+z;};
    x = 2;
    y = 10.1;
    z = 1;
    cout<<f()<<endl;
}
//结果：12.1
```



## 一、遍历算法：

### for算法：

```c++
for(auto& i : v) //auto后面要加&，才能改变容器内的值
{
    val++;
    cout<<"仿函数打印: "<<val<<" ";
}
```



### for_each算法：

作用：对有迭代器的容器每一个元素遍历执行一遍仿函数，具体要干嘛，在仿函数里定义

语法：

**无返回值**，需要仿函数

`for_each( v.begin() , v.end() , fanghanshu() )`，`fanghanshu`是类名，传递匿名对象

`for_each( v.begin() , v.end() , [](int& x){return x++; } )`，`lambda`表达式，x是虚拟传递值，只是表明规则

```c++
class my_print
{
public:
    void operator()(int& val) //需要注意采用引用的方式传递，才能改变容器本身
    {
        val++;
        cout<<"仿函数打印: "<<val<<" ";
    }
};

int main()
{
    vector<int> v1;
    for(int i=0 ; i<5 ;i++){
        v1.push_back(i);
    }
    //仿函数遍历
    for_each(v1.begin(),v1.end(),my_print()); //仿函数只需要提供一个准则，不需要传递参数
    //lambda遍历
    for_each(v1.begin(),v1.end(),[](int& x){cout<<"lambda表达式打印: "<<x<<endl;return x++;});
    //lambda和仿函数类似，参数列表中的x是虚拟值，和仿函数中的val一样，容器本身不需要王表达式中传递参数
    for(int i : v1){
        cout<<"for循环打印vector: "<<i<<endl;
    }
    return 0;
}
```



### **transform算法:**

作用：对**一个/或两个**容器中的数据进行处理，并搬运到新的容器中；

语法：v1和v2是两个待处理的容器，v3是新容器

**无返回值**，需要仿函数

- `transform(v1.begin() , v1.end() , v3.begin() , fanghanshu() )`  //待操作的容器需要用迭代器定义一个**拷贝区间**，新的容器只写																												一个**开始迭代器**
- `transform(v1.begin() , v1.end() , v2.begin() , v3.begin() , fanghanshu() )` //第二个带操作的容器也只写一个开始迭代器

使用事项：**新的容器必须提前扩充大小**

```C++
class fanghanshu
{
public:
    int operator()(int& val){ //重载一：自增
        val++;
        cout<<"单容器仿函数自增: "<<val<<endl;
        return val;
    }
    int operator()(int val1,int val2){ //重载二：两个容器相加
        cout<<"多容器仿函数相加: "<<val1+val2<<endl;
        return val1+val2;
    }
};

int main()
{
    vector<int> v1;
    vector<int> v1_1;
    for(int i = 0;i<10;i++){
        v1.push_back(i);
        v1_1.push_back(i+1);}
    vector<int> v2;
    vector<int> v3;
    v2.resize(v1.size()); //新容器使用前必须扩容
    v3.resize(v1.size()); //新容器使用前必须扩容
    transform(v1.begin(),v1.end(),v2.begin(), fanghanshu());
    transform(v1.begin(),v1.end(),v1_1.begin(), v2.begin(), fanghanshu());
    return 0;
}
```



## 二、查找算法

### find算法：

作用：找到容器中的特定元素，并返回相应的迭代器

返回值：**返回值是迭代器**，如果找到了，返回该位置的迭代器，否则返回end()迭代器。

语法：

`auto it = find(v.begin(),v.end(),value)` //value可以是任意的数据类型，也可以是自定义的

如果是自定义的value类型，和仿函数略微有些不一样，重载的不是`()`，而是`==`

```c++
#include<iostream>
#include <string>
#include<vector>
#include<algorithm>
using namespace std;

class people{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}
    bool operator==(string name){ //和仿函数不一样，需要重载的不是（），而是==
        if(name == this->name){
            return true;
        }
        else{return false;}
    }
};

void test01()
{
    people p1(18,"xc");
    people p2(19,"zn");
    vector<people> v={p1,p2};
    auto it = find(v.begin(),v.end(),"xc"); //这个value可以是任意的数据类型
    if(it==v.end())
    {
        cout<<"没有找到这个元素"<<endl;
    }
}
```



### find_if算法：

用法：相当于找一个if的判断条件，如果满足，返回迭代器，如果不满足，返回end（）

返回值：满足谓词中定义的if条件的**第一个**索引位置

```c++
#include<iostream>
#include <string>
#include<vector>
#include<algorithm>
using namespace std;

class people{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}
};

class isgreat_18{
public:
    bool operator()(people p)
    {
        return p.age>15; //如果大于15，返回真
    }
};

void test01(){
    people p1(18,"xc");
    people p2(19,"zn");
    vector<people> v={p1,p2};
    //返回值是第一个满足约束的元素
    auto it1 = find_if(v.begin(),v.end(),[](people x){return x.age>15;});  //lambda表达式
    auto it2 = find_if(v.begin(),v.end(),isgreat_18());					 //仿函数
    if(it2!=v.end()){
        cout<<it2->name;
    }
    else{
        cout<<"sorry";
    }
}

int main()
{
    test01();
}
```



















# 一、排序算法

## 1.冒泡算法

原理：相邻的两个元素为一组，对一组来说，如果前者大于后者，交换二者顺序，继续操作下一组，直到把最大值运到最后的位置，这个为外层一轮结束，执行n-1轮，示例如下：

<img src="picture\冒泡算法.png">

思路：

1. 分为两层循环，外层循环一次选出一个最大值放在最后面，内层循环负责比较**还未排序**的相邻两个元素的大小并交换位置
2. 列表中有n个元素，内层是需要考虑最后一个元素不能超过界限，外层需要进行n-1轮循环（最后一层就是两个比较，少一层是因为最后就剩一个数字了，不用再循环）
3. 外层(i=0)循环次数n-1，内层(j=0)循环次数n-1-i

代码实现：

```c++
#include<iostream>
using namespace std;

void sort(int *array,int len)
{
    //共有len个数，需要循环len-1轮，因为从0开始，因此是小于len-1
    for(int i=0;i<len-1;i++) 
    {
        //len-1是因为要保证最后一个元素不能超过界限，-i是因为第i轮已经确定了最后i个元素的大小，不用再遍历了
        for(int j = 0;j<len-1-i;j++)
        {
            if(array[j]>array[j+1])
            {
                int temp;
                temp = array[j+1];
                array[j+1] = array[j];
                array[j] = temp;
            }
        }
    }
}

int main()
{
    int array[]={1,6,4,3,2,0,3,7,2};
    int len = sizeof(array)/sizeof(array[0]);
    sort(array,len);
    for(int i=0;i<len;i++)
    {
        cout<<array[i]<<endl;
    }
    return 0;
}
```



## 2.选择算法

原理：默认最小元素的索引为起始元素，然后和后面的元素比较 ，如果后面元素更小，会替换更小元素的索引，遍历完后面所有元素后，会找到最小的元素，把它和（次）起始元素交换放在（次）起始位置

<img src="picture\选择算法.png">  

结构：

1. 分为两层循环，外层为一轮找到最小1个元素，内层为遍历当前元素后的所有元素，比较大小，替换最小索引
2. 内层循环结束后，交换最小索引和当前元素索引在元素中的位置
3. 外层结构（i=0）到n-1，内层循环从i+1开始，到n结束

```c++
#include<iostream>
using namespace std;

template<typename T>//告诉编译器后面的T是一个模板
void sort(T array,int len)
{
    //共有len个数，每一轮可以选出一个最大的数，需要循环len-1轮，因为从0开始，因此是小于len-1
    for(int i=0;i<len-1;i++) 
    {
        int min_index = i; //假设当前的i值是最小值
        for(int j = i+1;j<len;j++) //从i+1开始，每一个元素都得和上面的min比较
        {
            if(array[j]<array[min_index])  //找后面元素的最小索引
            {
                min_index = j;
            }
        }
        std::swap(array[i],array[min_index]);   //等每一轮找到最小值后再进行交换。最小的放在左边起始位置
    }
    for(int i = 0;i<len;i++)
    {
        cout<<array[i]<<endl;
    }
    cout<<"排序完毕"<<endl;
}

int main()
{
    int arr_d[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };
    int len_d = (int) sizeof(arr_d) / sizeof(*arr_d);
    //函数模板的两种输入方式
    xuanze(arr_d,len_d);       //方法一：自动类型推导
    xuanze<int*>(arr_d,len_d); //方法二：显示指定类型
    float arrf[] = { 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 };
    int len_f = (float) sizeof(arrf) / sizeof(*arrf);
    xuanze(arrf,len_f);
    xuanze<float*>(arrf,len_f);
    return 0;
}
```

