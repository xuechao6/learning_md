# 标准算法：

标准算法的实现都是依赖容器，一般是由迭代器的容器，输入的参数还包括**仿函数**或者是**lambda表达式**

## 内建函数对象

内涵：是STL内定义好的模板类（仿函数），覆盖了常用的算术、关系和逻辑仿函数

调用：包含头文件`#include<functional>`

注意：是一个类，需要实例化后才能用

内容：

- 算术仿函数：返回值类型和输入类型相同
- `template<class T> T plus<T>`                //加法仿函数
- `template<class T> T minus<T>`              //减法仿函数
- `template<class T> T multiplies<T>`    //乘法仿函数
- `template<class T> T divides<T>`         //除法仿函数
- `template<class T> T modulus<T>`         //取模仿函数
- `template<class T> T negate<T>`           //取反仿函数

* 关系仿函数：返回值都是bool类型
* `template<class T> bool equal_to<T>`                    //等于
* `template<class T> bool not_equal_to<T>`            //不等于
* `template<class T> bool greater<T>`                      //大于
* `template<class T> bool greater_equal<T>`          //大于等于
* `template<class T> bool less<T>`                           //小于
* `template<class T> bool less_equal<T>`               //小于等于

* 逻辑仿函数
* `template<class T> bool logical_and<T>`              //逻辑与
* `template<class T> bool logical_or<T>`                //逻辑或
* `template<class T> bool logical_not<T>`              //逻辑非



## 仿函数：

仿函数本质上是一个类，类内只有一个成员函数，重载了`()`符号，在重载的`()`函数中，里面定义了自己的规则

```c++
class my_print
{
public:
    void operator()(int val)
    {
        val++;
        cout<<val<<" ";
    }
};
```

仿函数重载的函数的输入，一定要和容器内存储的数据类型一样，这样使用算法时，容器中的数据才能传递进来

调用仿函数的时候可以有两种方式，1.匿名对象调用 2.实例化对象调用。一般采用匿名对象调用，简洁高效

```c++
class my_print //定义看上面
//匿名对象调用
for_each(v1.begin() , v1.end() , my_print()); //类名后面直接加（），并不进行实例化，是一个暂时性的对象，这句话结束后就会被释放
//实例化对象调用
my_print m1;
for_each(v1.begin() , v1.end() ,m1); 
```



## 谓词：

仿函数重载的运算符`()`的返回值如果是bool的返回值，称为**谓词**



## lambda表达式：

作用是模拟一个函数。作为一种参数传递的手段，可以从外部输入参数，利用lambda表达式定义匿名函数，好处是不需要在额外写一个函数体，更简洁

**语法**：`[捕获值](参数列表)->return type{ 函数返回公式;}`，**注意在{}内有分号**

- 捕获值：访问外部的变量，可以用值访问、引用访问等方式

  `[]`不捕获外部变量

  **值捕获=：**传递时赋值。调用前外部值变化，**表达式内值不会变化**

  `[=]：`捕获所有变量，return可以是所有变量的组合

  `[x]`：只捕获x变量，在return中只能使用x

  **引用捕获&：**调用前赋值。会随着外部值的变化而变化

  `[&]：`捕获所有变量

  `[&x]：`只捕获x变量

  **隐式捕获：**必须使用不同类型的捕获符号，大部分参数传递的方式应该写在**最前面**

  `[=，&x]`：除了x是引用传递，其他的变量都是值传递

  `[&,x]:`除了x是值传递，其他变量都是引用传递，注意不能写成`[x,&]`，会报错

  `[x,&y]:`值传递x，引用传递y

- 参数列表：lambda表达式模拟的函数，需要输入的参数。相当于正常函数的形参

- ->return type：返回值的类型，可以省略，也可以用->强制规定

- 函数返回公式：返回的具体计算方式，return表达式

```c++
#include<iostream>
using namespace std;

int main()
{
    int x =1;
    double y =2.1;
    int z =90;
    auto f = [&,x](){return x+y+z;};
    x = 2;
    y = 10.1;
    z = 1;
    cout<<f()<<endl;
}
//结果：12.1
```



## 算法语法总结

- **仿函数**
- `for_each( v.begin() , v.end() , fanghanshu() )`
- `transform( v1.begin() , v1.end() , fanghanshu() )`
- `transform( v1.begin() , v1.end() , v2.begin() , fanghanshu() )`
- **数值**：如果是自定义的数据value，需要在类内**重载符号==**
- `auto it = find( v1.begin() , v1.end() , value)`    //返回值是迭代器
- `int num = count( v1.begin() , v1.end() , value)`  //返回值是int
- `bool result = binary_search( v.begin() ,v.end() , value)` //返回值是bool，找没找到
- `replace( v1.begin() , v1.end() , value)`
- `accumulate( v1.begin() , v1.end() , value)` 起始累加值
- `fill( v1.begin() , v1.end() , value)`
- **谓词**
- `auto it = find_if( v1.begin() , v1.end() , _pred)` 
- `int num = count_if( v1.begin() , v1.end() , _pred)` 
- `sort( v1.begin() , v1.end() , _pred )`
- **无输入**
- `random_shuffle( v1.begin() , v1.end() )`
- `sort( v1.begin() , v1.end() )`
- `swap( v1 , v2 )`
- `auto it_end = set_...((v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget.begin())`



## 一、遍历算法

### for算法：

```c++
for(auto& i : v) //auto后面要加&，才能改变容器内的值
{
    val++;
    cout<<"仿函数打印: "<<val<<" ";
}
```



### for_each算法：

作用：对有迭代器的容器每一个元素遍历执行一遍仿函数，具体要干嘛，在仿函数里定义

语法：

**无返回值**，需要仿函数

`for_each( v.begin() , v.end() , fanghanshu() )`，`fanghanshu`是类名，传递匿名对象

`for_each( v.begin() , v.end() , [](int& x){return x++; } )`，`lambda`表达式，x是虚拟传递值，只是表明规则

```c++
class my_print
{
public:
    void operator()(int& val) //需要注意采用引用的方式传递，才能改变容器本身
    {
        val++;
        cout<<"仿函数打印: "<<val<<" ";
    }
};

int main()
{
    vector<int> v1;
    for(int i=0 ; i<5 ;i++){
        v1.push_back(i);
    }
    //仿函数遍历
    for_each(v1.begin(),v1.end(),my_print()); //仿函数只需要提供一个准则，不需要传递参数
    //lambda遍历
    for_each(v1.begin(),v1.end(),[](int& x){cout<<"lambda表达式打印: "<<x<<endl;return x++;});
    //lambda和仿函数类似，参数列表中的x是虚拟值，和仿函数中的val一样，容器本身不需要王表达式中传递参数
    for(int i : v1){
        cout<<"for循环打印vector: "<<i<<endl;
    }
    return 0;
}
```



### **transform算法:**

作用：对**一个/或两个**容器中的数据进行处理，并搬运到新的容器中；

语法：v1和v2是两个待处理的容器，v3是新容器

**无返回值**，需要仿函数

- `transform(v1.begin() , v1.end() , v3.begin() , fanghanshu() )`  //待操作的容器需要用迭代器定义一个**拷贝区间**，新的容器只写																												一个**开始迭代器**
- `transform(v1.begin() , v1.end() , v2.begin() , v3.begin() , fanghanshu() )` //第二个带操作的容器也只写一个开始迭代器

使用事项：**新的容器必须提前扩充大小**

```C++
class fanghanshu
{
public:
    int operator()(int& val){ //重载一：自增
        val++;
        cout<<"单容器仿函数自增: "<<val<<endl;
        return val;
    }
    int operator()(int val1,int val2){ //重载二：两个容器相加
        cout<<"多容器仿函数相加: "<<val1+val2<<endl;
        return val1+val2;
    }
};

int main()
{
    vector<int> v1;
    vector<int> v1_1;
    for(int i = 0;i<10;i++){
        v1.push_back(i);
        v1_1.push_back(i+1);}
    vector<int> v2;
    vector<int> v3;
    v2.resize(v1.size()); //新容器使用前必须扩容
    v3.resize(v1.size()); //新容器使用前必须扩容
    transform(v1.begin(),v1.end(),v2.begin(), fanghanshu());
    transform(v1.begin(),v1.end(),v1_1.begin(), v2.begin(), fanghanshu());
    return 0;
}
```



## 二、查找算法

### find算法：

作用：找到容器中的特定元素，并返回相应的迭代器，需要仿函数重载==

返回值：**返回值是迭代器**，如果找到了，返回该位置的迭代器，否则返回end()迭代器。

语法：

`auto it = find(v.begin(),v.end(),value)` //value可以是任意的数据类型，**也可以是自定义的**

如果是自定义的value类型，和仿函数略微有些不一样，重载的不是`()`，而是`==`

```c++
#include<iostream>
#include <string>
#include<vector>
#include<algorithm>
using namespace std;

class people{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}
    //重载1：字符串数据
    bool operator==(string name){ //和仿函数不一样，需要重载的不是（），而是==
        if(name == this->name){
            return true;
        }
        else{return false;}
    }
    //重载2：自定义数据
    bool operator==(people p)
    {
        if(p.name == this->name&&p.age == this->age)
        {
            return true;
        }
        else{return false;}
    }
};

void test01()
{
    people p1(18,"xc");
    people p2(19,"zn");
    vector<people> v={p1,p2};
    auto it = find(v.begin(),v.end(),"xc"); //这个value可以是任意的数据类型，包括自定义的
    if(it==v.end()){
        cout<<"没有找到这个元素"<<endl;}
    //自定义的数据查找
    people p3(18,"xc");
    auto it2 = find(v.begin(),v.end(),p3); //value传入整个对象
    cout<<"it2:"<<it2->name<<": "<<it2->age<<endl;
}
```



### find_if算法：

用法：相当于找一个if的判断条件，如果满足，返回迭代器，如果不满足，返回end（），需要插入谓词

返回值：满足谓词中定义的if条件的**第一个**索引位置

语法：`auto it = find_if(v.begin() , v.end() , fanghanshu())`

```c++
#include<iostream>
#include <string>
#include<vector>
#include<algorithm>
using namespace std;

class people{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}
};

class isgreat_18{
public:
    bool operator()(people p)
    {
        return p.age>15; //如果大于15，返回真
    }//仿函数可以是等于或者大于等逻辑值
};

void test01(){
    people p1(18,"xc");
    people p2(19,"zn");
    vector<people> v={p1,p2};
    //返回值是第一个满足约束的元素
    auto it1 = find_if(v.begin(),v.end(),[](people x){return x.age>15;});  //lambda表达式
    auto it2 = find_if(v.begin(),v.end(),isgreat_18());					 //仿函数
    if(it2!=v.end()){
        cout<<it2->name;
    }
    else{
        cout<<"sorry";
    }
}

int main()
{
    test01();
}
```



### count算法：

用法：统计一个容器中相同元素的个数，这个元素可以是标准的数据结构，也可以是自定义的数据结构

注意：统计自定义类时，需要在自定义的类内重载==符号，和find一样

语法：`int num = count(v.begin() , v.end() , value)`，value可以是自定义的对象

```c++
class people
{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}
    bool operator==(people p){ //自定义的类需要在类内重载==符号，count底层是根据相等==来统计个数的
        if(p.age == this->age &&p.name == this->name){
            return true;
        }else{
            return false;
        }
    }
};

int main(){
    vector<string> v={"a","b","c","a","a"};
    int num = count(v.begin(),v.end(),"a");
    cout<<"string类型的a个数为："<<num<<endl;

    people p1(18,"xc");people p2(19,"xc");people p3(19,"zn");
    vector<people> v2={p1,p2};
    int num2 = count(v2.begin(),v2.end(),p3);
    cout<<"people类型的p3个数为："<<num2<<endl;
    return 0;
}
```



### count_if算法：

作用：查找满足条件的元素的个数

语法：`int num = count_if(v.begin() , v.end() , 谓词)`

```c++
class people
{
public:
    int age;
    string name;
    people(string m_name,int m_age):name(m_name),age(m_age){}
    bool operator()(people p)
    {
        if(p.age == this->age && p.name == this->name){
            return true;
        }else{
            return false;
        }
    }
};

int main()
{
    vector<int> v;
    v={1,2,3,4,5,6,7,8};
    int num = count_if(v.begin(),v.end(),[](int x){return x>5;}); //lambda表达式
    cout<<"大于5的数量为："<<num<<endl;

    people p1("xc",18);
    people p2("zn",20);
    people p3("zn",20);
    vector<people> v2={p1,p2};
    //lambda表达式捕获外部参数
    int num2 = count_if(v2.begin(),v2.end(),[&p3](const people& p){return (p.age>5)&&(p.name == p3.name);});
    cout<<"people中同名且年龄大于5的数量为："<<num2<<endl;

    int num3 = count_if(v2.begin(),v2.end(),p3);
    cout<<"people中仿函数完全相同的数量为："<<num3<<endl;
    return 0;
}
```



### 四个算法的误区：

用处：

- find和count一般用来精确查找，因此底层实现是等于=查找
- find_if和count_if是条件查找，多用于大于，小于等逻辑判断

重载符号：

- find和count重载`==`
- find_if和count_if重载`()`，仿函数要求是一个谓词，或者lambda表达式

输入：

- find和count输入的是value，可以标准的，也可以是自定义的，
- find_if和count_if输入的是函数对象，可以用匿名仿函数或者lambda表达式代替



### binary_search算法：

作用：二分查找容器中的数据

注意事项：

- 只能查找**有序容器**，因为底层是基于二叉搜索树实现的，所以必须按照二叉树的规定，有序  ====>>>**和`set`容器天然适应**
- 返回值是**逻辑值**bool，不是迭代器，只能知道容器中有没有，不能确定具体位置

语法：`bool res = binary_search(v.begin() , v.end() , value)` //插入值是value，value可以是任意数据类型，包括自定义的，**不是仿函数**

```c++
int main()
{
    deque<int> q; //数字插入
    q.push_back(1);q.push_back(2);q.push_back(3); q.push_back(5); q.push_back(6); q.push_back(10); q.push_back(20);
    bool res = binary_search(q.begin(),q.end(),5);
    if(res){
        cout<<"找到啦"<<endl;
    }else{
        cout<<"没找到"<<endl;}

    deque<string> q1;
    //字符串的有序插入是按照第一个字符的ASCII码进行的，后面的字符顺序和多少不影响有序无序,和set容器的排序一样
    q1.push_back("azm");q1.push_back("b");q1.push_back("ca");q1.push_back("e");q1.push_back("g");q1.push_back("m");q1.push_back("zu");
    bool res2 = binary_search(q1.begin(),q1.end(),"ca");
    if(res2){
        cout<<"res2找到啦"<<endl;
    }else{
        cout<<"没找到"<<endl;}
    
    //和set容器天然适配
    set<string> s; 
    //无序插入也可以用binary_search，因为set自动排序
    s.insert("zm");s.insert("b");s.insert("ja");s.insert("e");s.insert("g");s.insert("m");s.insert("zu"); 
    bool res3 = binary_search(s.begin(),s.end(),"zm");
    if(res3){
        cout<<"set找到啦"<<endl;
    }else{
        cout<<"没找到"<<endl;}
}
```



## 三、排序算法

### sort算法：

作用：对一个容器按照指定逻辑排序，最常用

语法：`sort(v.begin() , v.end() , _pred`，默认的谓词可以忽略，按照**从小到大的顺序**排列，字符串按照首字符的ASCII码排序

```c++
class people
{
public:
    int age;
    string name;
    people(int m_age,string m_name): age(m_age) , name(m_name){}
};

int main()
{
    vector<int> v = {1,7,43,2,65,8,23};
    sort(v.begin(),v.end(),[](int a,int b){return a>b;});
    for_each(v.begin(),v.end(),[](int a){cout<<a<<",";});
    cout<<endl;
    //自定义的数据
    people p1(18,"xc");people p2(20,"zn");people p3(10,"bn");
    vector<people> v2 = {p1,p2,p3};
    sort(v2.begin(),v2.end(),[](people a,people b){return a.age>b.age;});
    for_each(v2.begin(),v2.end(),[](people a){cout<<a.name<<":"<<a.age<<" ";});
}
```



### random_shuffle算法：

作用：**洗牌算法**，随机打乱容器的顺序

语法：`random_shuffle(v.begin() , v.end())`

注意：要加**随机数种子**才能生效

```c++
int main()
{
    srand((unsigned int)time(NULL));
    //srand()是随机数种子，接收的参数类型是无符号整型，time(NULL)是从1970年的返回时间，NULL代表没有参数传递，前面的(unsigned int)是强制把类型转为无符号整形
    vector<int> v={1,2,4,5,7,423,2,76,42,3};
    for_each(v.begin(), v.end() , [](int a){cout<<a<<" ";});
    cout<<endl;
    random_shuffle(v.begin(),v.end()); //使用时记得加随机数种子
    for_each(v.begin(), v.end() , [](int a){cout<<a<<" ";});
}
```



### merge算法：

作用：将两个容器合并，存储到新的容器中，默认按照原来容器的有序方式重新排序

注意：两个容器必须都是有序，两个容器的大小可以不一样，新的容器需要提前开辟空间大小

语法：`merge(v1.begin() , v1.end() , v2.begin() ,v2.end() ,v3.begin() )`

```c++
    vector<int> v1={1,2,4,5,7};vector<int> v2={1,2,4,16,43,61};
    vector<int> v3;
    v3.resize(v1.size()+v2.size());
    cout<<endl;
    merge(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin());
    for_each(v3.begin(), v3.end() , [](int a){cout<<a<<" ";});
```



### reverse算法：

作用：翻转容器元素顺序，平时基本不用

语法：`reverse(v.begin() , v.end())`



## 四、替换算法

### replace算法：

作用：查找值相同的元素，把旧元素替换成新元素，元素可以是默认的数据类型也可以是自定义的数据类型

语法：`replace(v.begin() , v.end() , old_value , new_value)`value也可以是自定义的类，但是需要重载==符号

```c++
class people
{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}   
    bool operator==(people p){
        if(p.name == this->name&&p.age == this->age){
            return true;
        }else{return false;}
    }
};

int main()
{
    vector<int> v={1,2,4,5,7,423,2,76,42,3};
    cout<<"替换前：";
    for_each(v.begin(), v.end() , [](int a){cout<<a<<" ";});
    cout<<endl;
    cout<<"替换后：";
    replace(v.begin(),v.end(),2,2000);
    for_each(v.begin(), v.end() , [](int a){cout<<a<<" ";});

    people p1(18,"xc");people p2(19,"zn");
    vector<people> v2={p1,p2};
    people p3(119,"zn");
    replace(v2.begin(),v2.end(),p2,p3);
    for_each(v2.begin(), v2.end() , [](people a){cout<<a.name<<":"<<a.age;});
}
```



### replace_if算法：

作用：将容器内满足条件的元素，替换成新的元素，这两个算法和find_if与count_if一样

语法：`replace_if(v.begin() , v.end() , _pred , new_value)`

```c++
class people
{
public: 
    int age;
    string name;
    people(int m_age , string m_name):age(m_age),name(m_name){}   
};

int main()
{
    vector<int> v={1,2,4,5,7,423,2,76,42,3};
    cout<<"替换前：";
    for_each(v.begin(), v.end() , [](int a){cout<<a<<" ";});
    cout<<endl;
    cout<<"替换后：";
    replace_if(v.begin(),v.end(),[](int a){return a>5;},2000);
    for_each(v.begin(), v.end() , [](int a){cout<<a<<" ";});
    cout<<endl;

    people p1(18,"xc");people p2(19,"zn");
    vector<people> v2={p1,p2};
    people p3(119,"zn");
    replace_if(v2.begin(),v2.end(),[](people p){return p.age>10;},p3);
    for_each(v2.begin(), v2.end() , [](people a){cout<<a.name<<":"<<a.age<<" ";});
}
```



### swap算法：

作用：交换两个容器的元素

语法：`swap(v1,v2)`注意输入是容器，不是迭代器



## 五、算术算法

**包含的头文件为`<numeric>`**

### accumulate算法：

作用：计算容器内的数据累加值

语法：`double/int sum = accumulate(v.begin() , v.end() , begin_value)`,begin_value是默认的叠加值，通常设置为0

```c++
#include<numeric>
	vector<double> v;
    for(int i = 0;i<10;i++){
        v.push_back(i+0.5);
    }
    for_each(v.begin(),v.end(),[](double a){cout<<a<<" ";});
    double sum = accumulate(v.begin(),v.end(),0);
    cout<<"sum: "<<sum<<endl;
//结果：0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 sum: 45
```



### fill算法：

作用：在迭代器区间内填充数据，一般都在后面使用时进行修改，初始化可以用resize的重载版本规定填充的值

语法：`fill(v2.begin(),v2.end() ，value)`

```c++
    vector<double> v2;
    v2.resize(10);
    fill(v2.begin(),v2.end(),100);
    for_each(v2.begin(),v2.end(),[](double a){cout<<a<<" ";});
```



## 六、集合算法

注意：前提是需要容器是**有序容器**，目标容器接收时，需要提前扩容。算法有返回值，是满足条件的最后元素位置的迭代器，用这个迭代器可以避免resize带来的默认0值的问题

语法：`auto it_end = set_...((v1.begin(),v1.end(),v2.begin(),v2.end(),vtarget.begin())`

set_intersection算法：求交集

set_union算法：求并集

set_difference算法：求补集

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
    vector<int> v1,v2;
    for(int i =0;i<10;i++){ //必须是有序容器
        v1.push_back(i);
        v2.push_back(i+4);
    }
    cout<<"初始容器"<<endl;
    for_each(v1.begin(),v1.end(),[](int a){cout<<a<<" ";});
    cout<<endl;    
    for_each(v2.begin(),v2.end(),[](int a){cout<<a<<" ";});
    cout<<endl;
    vector<int> v3,v4,v5;//目标容器必须提前扩容

    v3.resize(min(v1.size(),v2.size())); //最糟糕的情况是全包围
    cout<<"交集"<<endl;
    //有返回值，是满足条件的元素的最后位置迭代器
    vector<int>::iterator  itend1 = set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin());
    for_each(v3.begin(),v3.end(),[](int a){cout<<a<<" ";}); //4 5 6 7 8 9 0 0 0 0
    cout<<endl;
    //使用输出的迭代器可以避免resize带来的0的影响
    for_each(v3.begin(),itend1,[](int a){cout<<a<<" ";}); //4 5 6 7 8 9
    cout<<endl;

    v4.resize(v1.size()+v2.size()); //最糟糕的情况是没有任何交集
    cout<<"并集"<<endl;
    vector<int>::iterator  itend2 = set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),v4.begin());
    for_each(v4.begin(),v4.end(),[](int a){cout<<a<<" ";}); //0 1 2 3 4 5 6 7 8 9 10 11 12 13 0 0 0 0 0 0 
    cout<<endl;
    for_each(v4.begin(),itend2,[](int a){cout<<a<<" ";}); //0 1 2 3 4 5 6 7 8 9 10 11 12 13
    cout<<endl;

    //补集分为a补b和b补a
    v5.resize(max(v1.size(),v2.size())); //最糟糕的情况是没有任何交集
    cout<<"补集"<<endl;
    cout<<"a补b"<<endl;
    vector<int>::iterator  itend3 = set_difference(v1.begin(),v1.end(),v2.begin(),v2.end(),v5.begin());
    for_each(v5.begin(),v5.end(),[](int a){cout<<a<<" ";}); //0 1 2 3 0 0 0 0 0 0
    cout<<endl;
    for_each(v5.begin(),itend3,[](int a){cout<<a<<" ";});  //0 1 2 3
    cout<<endl;
    cout<<"b补a"<<endl;
    vector<int>::iterator  itend4 = set_difference(v2.begin(),v2.end(),v1.begin(),v1.end(),v5.begin());
    for_each(v5.begin(),v5.end(),[](int a){cout<<a<<" ";}); //10 11 12 13 0 0 0 0 0 0
    cout<<endl;
    for_each(v5.begin(),itend4,[](int a){cout<<a<<" ";}); //10 11 12 13
    cout<<endl;
}
```



# 一、排序算法

## 1.冒泡算法

原理：相邻的两个元素为一组，对一组来说，如果前者大于后者，交换二者顺序，继续操作下一组，直到把最大值运到最后的位置，这个为外层一轮结束，执行n-1轮，示例如下：

<img src="picture\冒泡算法.png">

思路：

1. 分为两层循环，外层循环一次选出一个最大值放在最后面，内层循环负责比较**还未排序**的相邻两个元素的大小并交换位置
2. 列表中有n个元素，内层是需要考虑最后一个元素不能超过界限，外层需要进行n-1轮循环（最后一层就是两个比较，少一层是因为最后就剩一个数字了，不用再循环）
3. 外层(i=0)循环次数n-1，内层(j=0)循环次数n-1-i

代码实现：

```c++
#include<iostream>
using namespace std;

void sort(int *array,int len)
{
    //共有len个数，需要循环len-1轮，因为从0开始，因此是小于len-1
    for(int i=0;i<len-1;i++) 
    {
        //len-1是因为要保证最后一个元素不能超过界限，-i是因为第i轮已经确定了最后i个元素的大小，不用再遍历了
        for(int j = 0;j<len-1-i;j++)
        {
            if(array[j]>array[j+1])
            {
                int temp;
                temp = array[j+1];
                array[j+1] = array[j];
                array[j] = temp;
            }
        }
    }
}

int main()
{
    int array[]={1,6,4,3,2,0,3,7,2};
    int len = sizeof(array)/sizeof(array[0]);
    sort(array,len);
    for(int i=0;i<len;i++)
    {
        cout<<array[i]<<endl;
    }
    return 0;
}
```



## 2.选择算法

原理：默认最小元素的索引为起始元素，然后和后面的元素比较 ，如果后面元素更小，会替换更小元素的索引，遍历完后面所有元素后，会找到最小的元素，把它和（次）起始元素交换放在（次）起始位置

<img src="picture\选择算法.png">  

结构：

1. 分为两层循环，外层为一轮找到最小1个元素，内层为遍历当前元素后的所有元素，比较大小，替换最小索引
2. 内层循环结束后，交换最小索引和当前元素索引在元素中的位置
3. 外层结构（i=0）到n-1，内层循环从i+1开始，到n结束

```c++
#include<iostream>
using namespace std;

template<typename T>//告诉编译器后面的T是一个模板
void sort(T array,int len)
{
    //共有len个数，每一轮可以选出一个最大的数，需要循环len-1轮，因为从0开始，因此是小于len-1
    for(int i=0;i<len-1;i++) 
    {
        int min_index = i; //假设当前的i值是最小值
        for(int j = i+1;j<len;j++) //从i+1开始，每一个元素都得和上面的min比较
        {
            if(array[j]<array[min_index])  //找后面元素的最小索引
            {
                min_index = j;
            }
        }
        std::swap(array[i],array[min_index]);   //等每一轮找到最小值后再进行交换。最小的放在左边起始位置
    }
    for(int i = 0;i<len;i++)
    {
        cout<<array[i]<<endl;
    }
    cout<<"排序完毕"<<endl;
}

int main()
{
    int arr_d[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };
    int len_d = (int) sizeof(arr_d) / sizeof(*arr_d);
    //函数模板的两种输入方式
    xuanze(arr_d,len_d);       //方法一：自动类型推导
    xuanze<int*>(arr_d,len_d); //方法二：显示指定类型
    float arrf[] = { 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 };
    int len_f = (float) sizeof(arrf) / sizeof(*arrf);
    xuanze(arrf,len_f);
    xuanze<float*>(arrf,len_f);
    return 0;
}
```

